{"version":3,"file":"node-request.js","sources":["../../src/util/lowerCaseHeaders.ts","../../src/request/node/proxy.ts","../../src/request/node/tunnel.ts","../../src/request/node-request.ts","../../src/request/node/simpleConcat.ts","../../src/request/node/timedOut.ts"],"sourcesContent":["export function lowerCaseHeaders(headers: any) {\n  return Object.keys(headers || {}).reduce((acc, header) => {\n    acc[header.toLowerCase()] = headers[header]\n    return acc\n  }, {} as any)\n}\n","/**\n * Code borrowed from https://github.com/request/request\n * Apache License 2.0\n */\n\nimport url from 'url'\n\nfunction formatHostname(hostname: string) {\n  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'\n  return hostname.replace(/^\\.*/, '.').toLowerCase()\n}\n\nfunction parseNoProxyZone(zoneStr: string) {\n  const zone = zoneStr.trim().toLowerCase()\n\n  const zoneParts = zone.split(':', 2)\n  const zoneHost = formatHostname(zoneParts[0])\n  const zonePort = zoneParts[1]\n  const hasPort = zone.indexOf(':') > -1\n\n  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}\n}\n\nfunction uriInNoProxy(uri: any, noProxy: any) {\n  const port = uri.port || (uri.protocol === 'https:' ? '443' : '80')\n  const hostname = formatHostname(uri.hostname)\n  const noProxyList = noProxy.split(',')\n\n  // iterate through the noProxyList until it finds a match.\n  return noProxyList.map(parseNoProxyZone).some((noProxyZone: any) => {\n    const isMatchedAt = hostname.indexOf(noProxyZone.hostname)\n    const hostnameMatched =\n      isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length\n\n    if (noProxyZone.hasPort) {\n      return port === noProxyZone.port && hostnameMatched\n    }\n\n    return hostnameMatched\n  })\n}\n\nfunction getProxyFromUri(uri: any) {\n  // Decide the proper request proxy to use based on the request URI object and the\n  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)\n  // respect NO_PROXY environment variables (see: http://lynx.isc.org/current/breakout/lynx_help/keystrokes/environments.html)\n  const noProxy = process.env['NO_PROXY'] || process.env['no_proxy'] || ''\n\n  // if the noProxy is a wildcard then return null\n  if (noProxy === '*') {\n    return null\n  }\n\n  // if the noProxy is not empty and the uri is found return null\n  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {\n    return null\n  }\n\n  // Check for HTTP or HTTPS Proxy in environment, else default to null\n  if (uri.protocol === 'http:') {\n    return process.env['HTTP_PROXY'] || process.env['http_proxy'] || null\n  }\n\n  if (uri.protocol === 'https:') {\n    return (\n      process.env['HTTPS_PROXY'] ||\n      process.env['https_proxy'] ||\n      process.env['HTTP_PROXY'] ||\n      process.env['http_proxy'] ||\n      null\n    )\n  }\n\n  // if none of that works, return null\n  // (What uri protocol are you using then?)\n  return null\n}\n\nfunction getHostFromUri(uri: any) {\n  let host = uri.host\n\n  // Drop :port suffix from Host header if known protocol.\n  if (uri.port) {\n    if (\n      (uri.port === '80' && uri.protocol === 'http:') ||\n      (uri.port === '443' && uri.protocol === 'https:')\n    ) {\n      host = uri.hostname\n    }\n  }\n\n  return host\n}\n\nfunction getHostHeaderWithPort(uri: any) {\n  const port = uri.port || (uri.protocol === 'https:' ? '443' : '80')\n  return `${uri.hostname}:${port}`\n}\n\nexport function rewriteUriForProxy(reqOpts: any, uri: any, proxy: any) {\n  const headers = reqOpts.headers || {}\n  const options = Object.assign({}, reqOpts, {headers})\n  headers.host = headers.host || getHostHeaderWithPort(uri)\n  options.protocol = proxy.protocol || options.protocol\n  options.hostname = proxy.host.replace(/:\\d+/, '')\n  options.port = proxy.port\n  options.host = getHostFromUri(Object.assign({}, uri, proxy))\n  options.href = `${options.protocol}//${options.host}${options.path}`\n  options.path = url.format(uri)\n  return options\n}\n\nexport function getProxyOptions(options: any) {\n  let proxy\n  // eslint-disable-next-line no-prototype-builtins\n  if (options.hasOwnProperty('proxy')) {\n    proxy = options.proxy\n  } else {\n    const uri = url.parse(options.url)\n    proxy = getProxyFromUri(uri)\n  }\n\n  return typeof proxy === 'string' ? url.parse(proxy) : proxy\n}\n","/**\n * Code borrowed from https://github.com/request/request\n * Modified to be less request-specific, more functional\n * Apache License 2.0\n */\nimport * as tunnel from 'tunnel-agent'\nimport url from 'url'\n\nconst uriParts = [\n  'protocol',\n  'slashes',\n  'auth',\n  'host',\n  'port',\n  'hostname',\n  'hash',\n  'search',\n  'query',\n  'pathname',\n  'path',\n  'href',\n]\n\nconst defaultProxyHeaderWhiteList = [\n  'accept',\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept-ranges',\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-md5',\n  'content-range',\n  'content-type',\n  'connection',\n  'date',\n  'expect',\n  'max-forwards',\n  'pragma',\n  'referer',\n  'te',\n  'user-agent',\n  'via',\n]\n\nconst defaultProxyHeaderExclusiveList = ['proxy-authorization']\n\nexport function shouldEnable(options: any) {\n  // Tunnel HTTPS by default. Allow the user to override this setting.\n\n  // If user has specified a specific tunnel override...\n  if (typeof options.tunnel !== 'undefined') {\n    return Boolean(options.tunnel)\n  }\n\n  // If the destination is HTTPS, tunnel.\n  const uri = url.parse(options.url)\n  if (uri.protocol === 'https:') {\n    return true\n  }\n\n  // Otherwise, do not use tunnel.\n  return false\n}\n\nexport function applyAgent(opts: any = {}, proxy: any) {\n  const options = Object.assign({}, opts)\n\n  // Setup proxy header exclusive list and whitelist\n  const proxyHeaderWhiteList = defaultProxyHeaderWhiteList\n    .concat(options.proxyHeaderWhiteList || [])\n    .map((header) => header.toLowerCase())\n\n  const proxyHeaderExclusiveList = defaultProxyHeaderExclusiveList\n    .concat(options.proxyHeaderExclusiveList || [])\n    .map((header) => header.toLowerCase())\n\n  // Get the headers we should send to the proxy\n  const proxyHeaders = getAllowedProxyHeaders(options.headers, proxyHeaderWhiteList)\n  proxyHeaders.host = constructProxyHost(options)\n\n  // Reduce headers to the ones not exclusive for the proxy\n  options.headers = Object.keys(options.headers || {}).reduce((headers, header) => {\n    const isAllowed = proxyHeaderExclusiveList.indexOf(header.toLowerCase()) === -1\n    if (isAllowed) {\n      headers[header] = options.headers[header]\n    }\n\n    return headers\n  }, {} as any)\n\n  const tunnelFn = getTunnelFn(options, proxy)\n  const tunnelOptions = constructTunnelOptions(options, proxy, proxyHeaders)\n  options.agent = tunnelFn(tunnelOptions)\n\n  return options\n}\n\nfunction getTunnelFn(options: any, proxy: any) {\n  const uri = getUriParts(options)\n  const tunnelFnName = constructTunnelFnName(uri, proxy)\n  return tunnel[tunnelFnName]\n}\n\nfunction getUriParts(options: any) {\n  return uriParts.reduce((uri, part) => {\n    uri[part] = options[part]\n    return uri\n  }, {} as any)\n}\n\ntype UriProtocol = `http` | `https`\ntype ProxyProtocol = `Http` | `Https`\nfunction constructTunnelFnName(uri: any, proxy: any): `${UriProtocol}Over${ProxyProtocol}` {\n  const uriProtocol = uri.protocol === 'https:' ? 'https' : 'http'\n  const proxyProtocol = proxy.protocol === 'https:' ? 'Https' : 'Http'\n  return `${uriProtocol}Over${proxyProtocol}`\n}\n\nfunction constructProxyHost(uri: any) {\n  const port = uri.port\n  const protocol = uri.protocol\n  let proxyHost = `${uri.hostname}:`\n\n  if (port) {\n    proxyHost += port\n  } else if (protocol === 'https:') {\n    proxyHost += '443'\n  } else {\n    proxyHost += '80'\n  }\n\n  return proxyHost\n}\n\nfunction getAllowedProxyHeaders(headers: any, whiteList: any): any {\n  return Object.keys(headers)\n    .filter((header) => whiteList.indexOf(header.toLowerCase()) !== -1)\n    .reduce((set: any, header: any) => {\n      set[header] = headers[header]\n      return set\n    }, {})\n}\n\nfunction constructTunnelOptions(options: any, proxy: any, proxyHeaders: any) {\n  return {\n    proxy: {\n      host: proxy.hostname,\n      port: +proxy.port,\n      proxyAuth: proxy.auth,\n      headers: proxyHeaders,\n    },\n    headers: options.headers,\n    ca: options.ca,\n    cert: options.cert,\n    key: options.key,\n    passphrase: options.passphrase,\n    pfx: options.pfx,\n    ciphers: options.ciphers,\n    rejectUnauthorized: options.rejectUnauthorized,\n    secureOptions: options.secureOptions,\n    secureProtocol: options.secureProtocol,\n  }\n}\n","import decompressResponse from 'decompress-response'\nimport follow, {type FollowResponse, type RedirectableRequest} from 'follow-redirects'\nimport type {FinalizeNodeOptionsPayload, HttpRequest, MiddlewareResponse} from 'get-it'\nimport http from 'http'\nimport https from 'https'\nimport progressStream from 'progress-stream'\nimport qs from 'querystring'\nimport {Readable, type Stream} from 'stream'\nimport url from 'url'\n\nimport {lowerCaseHeaders} from '../util/lowerCaseHeaders'\nimport {getProxyOptions, rewriteUriForProxy} from './node/proxy'\nimport {concat} from './node/simpleConcat'\nimport {timedOut} from './node/timedOut'\nimport * as tunneling from './node/tunnel'\n\n/**\n * Taken from:\n * https://github.com/sindresorhus/is-stream/blob/fb8caed475b4107cee3c22be3252a904020eb2d4/index.js#L3-L6\n */\nconst isStream = (stream: any): stream is Stream =>\n  stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function'\n\n/** @public */\nexport const adapter = 'node' satisfies import('../types').RequestAdapter\n\nexport class NodeRequestError extends Error {\n  request: http.ClientRequest\n  code?: string | undefined\n\n  constructor(err: NodeJS.ErrnoException, req: any) {\n    super(err.message)\n    this.request = req\n    this.code = err.code\n  }\n}\n\n// Reduce a fully fledged node-style response object to\n// something that works in both browser and node environment\nconst reduceResponse = (\n  res: any,\n  reqUrl: string,\n  method: string,\n  body: any,\n): MiddlewareResponse => ({\n  body,\n  url: reqUrl,\n  method: method,\n  headers: res.headers,\n  statusCode: res.statusCode,\n  statusMessage: res.statusMessage,\n})\n\nexport const httpRequester: HttpRequest = (context, cb) => {\n  const {options} = context\n  const uri = Object.assign({}, url.parse(options.url))\n\n  if (typeof fetch === 'function' && options.fetch) {\n    const controller = new AbortController()\n    const reqOpts = context.applyMiddleware('finalizeOptions', {\n      ...uri,\n      method: options.method,\n      headers: {\n        ...(typeof options.fetch === 'object' && options.fetch.headers\n          ? lowerCaseHeaders(options.fetch.headers)\n          : {}),\n        ...lowerCaseHeaders(options.headers),\n      },\n      maxRedirects: options.maxRedirects,\n    }) as FinalizeNodeOptionsPayload\n    const fetchOpts = {\n      credentials: options.withCredentials ? 'include' : 'omit',\n      ...(typeof options.fetch === 'object' ? options.fetch : {}),\n      method: reqOpts.method,\n      headers: reqOpts.headers,\n      body: options.body,\n      signal: controller.signal,\n    } satisfies RequestInit\n\n    // Allow middleware to inject a response, for instance in the case of caching or mocking\n    const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n      adapter,\n      context,\n    })\n\n    // If middleware injected a response, treat it as we normally would and return it\n    // Do note that the injected response has to be reduced to a cross-environment friendly response\n    if (injectedResponse) {\n      const cbTimer = setTimeout(cb, 0, null, injectedResponse)\n      const cancel = () => clearTimeout(cbTimer)\n      return {abort: cancel}\n    }\n\n    const request = fetch(options.url, fetchOpts)\n\n    // Let middleware know we're about to do a request\n    context.applyMiddleware('onRequest', {options, adapter, request, context})\n\n    request\n      .then(async (res) => {\n        const body = options.rawBody ? res.body : await res.text()\n\n        const headers = {} as Record<string, string>\n        res.headers.forEach((value, key) => {\n          headers[key] = value\n        })\n\n        cb(null, {\n          body,\n          url: res.url,\n          method: options.method!,\n          headers,\n          statusCode: res.status,\n          statusMessage: res.statusText,\n        })\n      })\n      .catch((err) => {\n        if (err.name == 'AbortError') return\n        cb(err)\n      })\n\n    return {abort: () => controller.abort()}\n  }\n\n  const bodyType = isStream(options.body) ? 'stream' : typeof options.body\n  if (\n    bodyType !== 'undefined' &&\n    bodyType !== 'stream' &&\n    bodyType !== 'string' &&\n    !Buffer.isBuffer(options.body)\n  ) {\n    throw new Error(`Request body must be a string, buffer or stream, got ${bodyType}`)\n  }\n\n  const lengthHeader: any = {}\n  if (options.bodySize) {\n    lengthHeader['content-length'] = options.bodySize\n  } else if (options.body && bodyType !== 'stream') {\n    lengthHeader['content-length'] = Buffer.byteLength(options.body)\n  }\n\n  // Make sure callback is not called in the event of a cancellation\n  let aborted = false\n  const callback = (err: Error | null, res?: MiddlewareResponse) => !aborted && cb(err, res)\n  context.channels.abort.subscribe(() => {\n    aborted = true\n  })\n\n  // Create a reduced subset of options meant for the http.request() method\n  let reqOpts: any = Object.assign({}, uri, {\n    method: options.method,\n    headers: Object.assign({}, lowerCaseHeaders(options.headers), lengthHeader),\n    maxRedirects: options.maxRedirects,\n  })\n\n  // Figure out proxying/tunnel options\n  const proxy = getProxyOptions(options)\n  const tunnel = proxy && tunneling.shouldEnable(options)\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context,\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setImmediate(callback, null, injectedResponse)\n    const abort = () => clearImmediate(cbTimer)\n    return {abort}\n  }\n\n  // We're using the follow-redirects module to transparently follow redirects\n  if (options.maxRedirects !== 0) {\n    reqOpts.maxRedirects = options.maxRedirects || 5\n  }\n\n  // Apply currect options for proxy tunneling, if enabled\n  if (proxy && tunnel) {\n    reqOpts = tunneling.applyAgent(reqOpts, proxy)\n  } else if (proxy && !tunnel) {\n    reqOpts = rewriteUriForProxy(reqOpts, uri, proxy)\n  }\n\n  // Handle proxy authorization if present\n  if (!tunnel && proxy && proxy.auth && !reqOpts.headers['proxy-authorization']) {\n    const [username, password] = proxy.auth.username\n      ? [proxy.auth.username, proxy.auth.password]\n      : proxy.auth.split(':').map((item: any) => qs.unescape(item))\n\n    const auth = Buffer.from(`${username}:${password}`, 'utf8')\n    const authBase64 = auth.toString('base64')\n    reqOpts.headers['proxy-authorization'] = `Basic ${authBase64}`\n  }\n\n  // Figure out transport (http/https, forwarding/non-forwarding agent)\n  const transport = getRequestTransport(reqOpts, proxy, tunnel)\n  if (typeof options.debug === 'function' && proxy) {\n    options.debug(\n      'Proxying using %s',\n      reqOpts.agent ? 'tunnel agent' : `${reqOpts.host}:${reqOpts.port}`,\n    )\n  }\n\n  // See if we should try to request a compressed response (and decompress on return)\n  const tryCompressed = reqOpts.method !== 'HEAD'\n  if (tryCompressed && !reqOpts.headers['accept-encoding'] && options.compress !== false) {\n    reqOpts.headers['accept-encoding'] =\n      // Workaround Bun not supporting brotli: https://github.com/oven-sh/bun/issues/267\n      typeof Bun !== 'undefined' ? 'gzip, deflate' : 'br, gzip, deflate'\n  }\n\n  let _res: http.IncomingMessage | undefined\n  const finalOptions = context.applyMiddleware(\n    'finalizeOptions',\n    reqOpts,\n  ) as FinalizeNodeOptionsPayload\n  const request = transport.request(finalOptions, (response) => {\n    const res = tryCompressed ? decompressResponse(response) : response\n    _res = res\n    const resStream = context.applyMiddleware('onHeaders', res, {\n      headers: response.headers,\n      adapter,\n      context,\n    })\n\n    // On redirects, `responseUrl` is set\n    const reqUrl = 'responseUrl' in response ? response.responseUrl : options.url\n\n    if (options.stream) {\n      callback(null, reduceResponse(res, reqUrl, reqOpts.method, resStream))\n      return\n    }\n\n    // Concatenate the response body, then parse the response with middlewares\n    concat(resStream, (err: any, data: any) => {\n      if (err) {\n        return callback(err)\n      }\n\n      const body = options.rawBody ? data : data.toString()\n      const reduced = reduceResponse(res, reqUrl, reqOpts.method, body)\n      return callback(null, reduced)\n    })\n  })\n\n  function onError(err: NodeJS.ErrnoException) {\n    // HACK: If we have a socket error, and response has already been assigned this means\n    // that a response has already been sent. According to node.js docs, this is\n    // will result in the response erroring with an error code of 'ECONNRESET'.\n    // We first destroy the response, then the request, with the same error. This way the\n    // error is forwarded to both the response and the request.\n    // See the event order outlined here https://nodejs.org/api/http.html#httprequesturl-options-callback for how node.js handles the different scenarios.\n    if (_res) _res.destroy(err)\n    request.destroy(err)\n  }\n\n  request.once('socket', (socket: NodeJS.Socket) => {\n    socket.once('error', onError)\n    request.once('response', (response) => {\n      response.once('end', () => {\n        socket.removeListener('error', onError)\n      })\n    })\n  })\n\n  request.once('error', (err: NodeJS.ErrnoException) => {\n    if (_res) return\n    // The callback has already been invoked. Any error should be sent to the response.\n    callback(new NodeRequestError(err, request))\n  })\n\n  if (options.timeout) {\n    timedOut(request, options.timeout)\n  }\n\n  // Cheating a bit here; since we're not concerned about the \"bundle size\" in node,\n  // and modifying the body stream would be sorta tricky, we're just always going\n  // to put a progress stream in the middle here. Note that\n  const {bodyStream, progress} = getProgressStream(options)\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request, context, progress})\n\n  if (bodyStream) {\n    bodyStream.pipe(request)\n  } else {\n    request.end(options.body)\n  }\n\n  return {abort: () => request.abort()}\n}\n\nfunction getProgressStream(options: any) {\n  if (!options.body) {\n    return {}\n  }\n\n  const bodyIsStream = isStream(options.body)\n  const length = options.bodySize || (bodyIsStream ? null : Buffer.byteLength(options.body))\n  if (!length) {\n    return bodyIsStream ? {bodyStream: options.body} : {}\n  }\n\n  const progress = progressStream({time: 16, length})\n  const bodyStream = bodyIsStream ? options.body : Readable.from(options.body)\n  return {bodyStream: bodyStream.pipe(progress), progress}\n}\n\nfunction getRequestTransport(\n  reqOpts: any,\n  proxy: any,\n  tunnel: any,\n): {\n  request: (\n    options: any,\n    callback: (response: http.IncomingMessage | (http.IncomingMessage & FollowResponse)) => void,\n  ) => http.ClientRequest | RedirectableRequest<http.ClientRequest, http.IncomingMessage>\n} {\n  const isHttpsRequest = reqOpts.protocol === 'https:'\n  const transports =\n    reqOpts.maxRedirects === 0\n      ? {http: http, https: https}\n      : {http: follow.http, https: follow.https}\n\n  if (!proxy || tunnel) {\n    return isHttpsRequest ? transports.https : transports.http\n  }\n\n  // Assume the proxy is an HTTPS proxy if port is 443, or if there is a\n  // `protocol` option set that starts with https\n  let isHttpsProxy = proxy.port === 443\n  if (proxy.protocol) {\n    isHttpsProxy = /^https:?/.test(proxy.protocol)\n  }\n\n  return isHttpsProxy ? transports.https : transports.http\n}\n","/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexport function concat(stream: any, cb: any) {\n  const chunks: any = []\n  stream.on('data', function (chunk: any) {\n    chunks.push(chunk)\n  })\n  stream.once('end', function () {\n    if (cb) cb(null, Buffer.concat(chunks))\n    cb = null\n  })\n  stream.once('error', function (err: any) {\n    if (cb) cb(err)\n    cb = null\n  })\n}\n","// Copied from `@sanity/timed-out`\n\nimport type {IncomingMessage} from 'node:http'\nimport type {Socket} from 'node:net'\n\nexport function timedOut(req: any, time: any) {\n  if (req.timeoutTimer) {\n    return req\n  }\n\n  const delays = isNaN(time) ? time : {socket: time, connect: time}\n  const hostHeader = req.getHeader('host')\n  const host = hostHeader ? ' to ' + hostHeader : ''\n\n  if (delays.connect !== undefined) {\n    req.timeoutTimer = setTimeout(function timeoutHandler() {\n      const e: NodeJS.ErrnoException = new Error('Connection timed out on request' + host)\n      e.code = 'ETIMEDOUT'\n      req.destroy(e)\n    }, delays.connect)\n  }\n\n  // Clear the connection timeout timer once a socket is assigned to the\n  // request and is connected.\n  req.on('socket', function assign(socket: Socket) {\n    // Socket may come from Agent pool and may be already connected.\n    if (!socket.connecting) {\n      connect(socket)\n      return\n    }\n\n    socket.once('connect', () => connect(socket))\n  })\n\n  function clear() {\n    if (req.timeoutTimer) {\n      clearTimeout(req.timeoutTimer)\n      req.timeoutTimer = null\n    }\n  }\n\n  function connect(socket: Socket) {\n    clear()\n\n    if (delays.socket !== undefined) {\n      const socketTimeoutHandler = () => {\n        const e: NodeJS.ErrnoException = new Error('Socket timed out on request' + host)\n        e.code = 'ESOCKETTIMEDOUT'\n        socket.destroy(e)\n      }\n\n      socket.setTimeout(delays.socket, socketTimeoutHandler)\n      req.once('response', (response: IncomingMessage) => {\n        response.once('end', () => {\n          socket.removeListener('timeout', socketTimeoutHandler)\n        })\n      })\n    }\n  }\n\n  return req.on('error', clear)\n}\n"],"names":["lowerCaseHeaders","headers","Object","keys","reduce","acc","header","toLowerCase","formatHostname","hostname","replace","parseNoProxyZone","zoneStr","zone","trim","zoneParts","split","port","hasPort","indexOf","getProxyFromUri","uri","noProxy","process","env","NO_PROXY","no_proxy","protocol","map","some","noProxyZone","isMatchedAt","hostnameMatched","length","uriInNoProxy","HTTP_PROXY","http_proxy","HTTPS_PROXY","https_proxy","uriParts","defaultProxyHeaderWhiteList","defaultProxyHeaderExclusiveList","applyAgent","opts","proxy","options","assign","proxyHeaderWhiteList","concat","proxyHeaderExclusiveList","proxyHeaders","whiteList","filter","set","host","proxyHost","constructProxyHost","tunnelFn","part","getUriParts","tunnelFnName","uriProtocol","proxyProtocol","constructTunnelFnName","tunnel","getTunnelFn","tunnelOptions","proxyAuth","auth","ca","cert","key","passphrase","pfx","ciphers","rejectUnauthorized","secureOptions","secureProtocol","constructTunnelOptions","agent","isStream","stream","pipe","adapter","NodeRequestError","Error","request","code","constructor","err","req","super","message","this","reduceResponse","res","reqUrl","method","body","url","statusCode","statusMessage","httpRequester","context","cb","parse","fetch","controller","AbortController","reqOpts","applyMiddleware","maxRedirects","fetchOpts","credentials","withCredentials","signal","injectedResponse","cbTimer","setTimeout","abort","clearTimeout","then","async","rawBody","text","forEach","value","status","statusText","catch","name","bodyType","Buffer","isBuffer","lengthHeader","bodySize","byteLength","aborted","callback","channels","subscribe","hasOwnProperty","getProxyOptions","tunneling.shouldEnable","setImmediate","clearImmediate","tunneling.applyAgent","getHostHeaderWithPort","getHostFromUri","href","path","format","rewriteUriForProxy","username","password","item","qs","unescape","authBase64","from","toString","transport","isHttpsRequest","transports","http","https","follow","isHttpsProxy","test","getRequestTransport","debug","tryCompressed","_res","compress","Bun","finalOptions","response","decompressResponse","resStream","responseUrl","chunks","on","chunk","push","once","data","reduced","onError","destroy","socket","removeListener","timeout","time","timeoutTimer","delays","isNaN","connect","hostHeader","getHeader","clear","socketTimeoutHandler","e","connecting","timedOut","bodyStream","progress","bodyIsStream","progressStream","Readable","getProgressStream","end"],"mappings":"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"}